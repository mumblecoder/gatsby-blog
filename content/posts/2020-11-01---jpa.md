---
title: JPA - persistence context, flush()
date: "2020-11-01T23:14:24.592Z"
template: "post"
draft: false
slug: "jpa"
category: "Daily"
tags:
  - "Jpa"
description: "JPA의 주요 개념들중 persistence context와 flush()에 대해 알아보자"
---

### 영속성 컨텍스트 (persistence context)
- 엔티티를 영구 저장하는 환경
- 영속성 컨텍스트는 엔티티 메니저를 생성할 때 하나 만들어진다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

### 엔티티의 생명주기
- 엔티티에는 4가지 상태가 존재한다.
    1. 비영속
        - 영속성 컨텍스트와 전혀 관계가 없는 상태
        - 엔티티 객체를 생성하고 저장하지 않았다면 영속성 컨텍스트나 DB와는 전혀 관련이 없다. 이런 상태를 비영속이라 한다.
    2. 영속
        - 영속성 컨텍스트에 저장된 상태
        - 비영속 상태에서 엔티티 매니저를 통해 저장했거나, 엔티티 매니저로 조회한 엔티티도 영속상태이다.
    3. 준영속
        - 영속성 컨텍스트에 저장되었다가 분리된 상태
        - 특정 엔티티를 준영속 상태로 만들려면 detach()를 호출 또는  close(), clear()를 호출해서 영속성 컨텍스트를 닫거나 초기화 해도 영속상태의 엔티티는 준영속 상태가 된다.
    4. 삭제
        - 삭제된 상태
        - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다. (remove())

### 영속성 컨텍스트의 특징
1. 영속성 컨텍스트와 식별자 값
    - 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
    - 영속상태는 식별자 값이 반드시 있어야 한다. 없으면 예외 발생
2. 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다.
    - 위 과정을 Flush라고 한다.
3. 영속성 컨텍스트가 엔티티를 관리했을떄의 장점
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩

### flush() (플러시)
- flush는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.
- flush를 실행하면 다음과 같은 일이 일어난다.
    1. 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.
    2. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
    3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

### flush 방법
1. em.flush() 직접 호출
    - 테스트나 다른 프레임워크와 JPA를 함께 사용할 때를 제외하고 거의 사용하지 않는다.
2. 트랜잭션 커밋시 플러시 자동호출
    - DB에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 변화도 DB에 반영되지 않는다.
    - JPA는 이런 문제를 예방하기 위해 트랜잭션을 커밋할 때 플러시를 자동 호출한다.
3. JPQL 쿼리 실행시 플러시 자동호출
    - em.persist()를 호출해서 영속 상태로 만든 객체들은 flush전 까지 DB에서 조회 할 수 없다.
    - 그러므로 JPQL을 실행할때 flush를 자동 호출하여 영속성 컨텍스트에 변경사항을 DB에 반영한 후 쿼리를 진행한다.


<hr>

> Reference
- 자바 ORM 표준 JPA 프로그래밍