GC (Garbage Collection)
- Java는 automatic memory management
- 자바에서는 메모리를 GC라는 알고리즘을 통하여 관리하기 때문에 개발자가 메모리를 처리하기 위한 로직을 만들 필요가 없고, 만들어서도 안된다.
- 자바에서 쓰레기는 객체이다. 객체는 메모리를 점유하고, 필요하지 않으면 메모리에서 해제되어야 한다.
- 쓰레기 객체를 효과적으로 처리하는 작업을 GC라고 한다.

자바에서 사용하는 메모리 영역
1. PC 레지스터
2. JVM 스택
3. 힙(Heap) -> GC가 발생하는 영역
4. 메서드 영역
5. 런타임 상수 풀
6. 네이티브 메서드 스택

Heap 메모리
- 클래스 인스턴스, 배열이 이 메모리에 쌓인다.
- 이 메모리는 공유메모리라고도 불리며 여러 스레드에서 공유하는 데이터들이 저장되는 메모리다.

Non-Heap 메모리
- 자바의 내부처리를 위해서 필요한 영역이다.
- 여기서 주된 영역은 메서드 영역이다. 영역별로 알아보자.
    1. 메서드 영역
        - 메서드 영역은 모든 JVM 스레드에서 공유한다.
    2. JVM 스택
    - 스레드가 시작할때 JVM 스택이 생성된다.
    - 이 스택에는 메서드가 호출되는 정보인 프레임이 저장된다.
    - 지역변수와 임시결과, 메서드 수행과 리턴에 관련된 정보들도 포함된다.

    3. 네이티브 메서드 스택
        - 자바 코드가 아닌 다른 언어로 된 코드들이 실행하게 될 때의 스택 정보를 관리한다.

    4. PC 레지스터
        - 자바의 스레드들은 각자의 PC 레지스터를 갖는다.
        - 네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 인스트럭션 주소를 PC 레지스터에 보관한다.

Heap영역과 메서드 영역은 JVM이 시작될 때 생성된다,

GC의 역할
- 메모리 할당
- 사용 중인 메모리 인식
- 사용하지 않는 메모리 인식

Heap-Memory
![힙메모리 구조](/img/java-heap-memory.png)
- 힙 메모리는 크게 Young, Old, Perm영역으로 나뉜다. 
- 하지만 Perm영역은 자바언어 레벨에서 거의 사용되지 않고, JDK8부터는 이 영역이 사라지므로 없는걸로 생각해도 된다.
- Virtual이라고 표시된 부분은 가상 영역이므로 고려하지 않아도 된다.
- 결과적으로 고려해야할 영역은 Young양역의 Eden 영역과 두개의 Servivor 영역, Old영역이다.

객체 생성시 메모리 프로세스
1. 메모리에 객체가 생성되면, Eden 영역에 객체가 지정된다.
2. Eden영역에 데이터가 꽉 차면, 이 영역에 있던 객체가 Servivor영역으로 옮겨진다. 이 때 Servivor 영역중 한 영역은 무조건 비어있어야한다.
3. Eden영역에 있던 객체 중 GC후 살아남은 객체들은 Servivor영역중 한 곳으로 이동한다.
4. Servivor영역이 차면 GC가 되고 Eden, Servivor 영역에서 살아남은 객체들이 비어있는 Servivor영역으로 이동한다.
5. 이러한 작업이 반복되면서 Servivor 1,2를 왔다갔다하던 객체들은 Old영역으로 이동한다.
6. 객체의 크기가 Servivor영역 크기보다 큰 경우엔 바로 Old 영역으로 넘어간다.

GC의 종류
1. 마이너GC - Young영역에서 발생하는 GC
2. 메이저GC - Old 영역이나 Perm 영역에서 발생하는 GC

GC 방식
- 아래 방식들은 WAS나 자바 애플리케이션 수행 시 옵션을 지정하여 선택할 수 있다.
    1. Serial Collector
        - Young영역과 Old영역이 연속적으로 처리되며 하나의 CPU를 사용한다.
        - 콜렉션이 수행될 때 애플리케이션 수행이 정지된다.
        - Old 영역의 GC는 Mark-sweep-compact콜렉션 알고리즘을 사용한다. (표사-스윕-컴팩션 과정)
    2. Parallel Collector
        - 스루풋 콜렉터로도 알려진 방식이다. 이 방식의 목표는 다른 CPU가 대기 상태로 남아 있는 것을 최소화하는 것이다.
        - 콜렉션을 병렬로 처리한다
        - 많은 CPU를 사용하기 때문에 GC의 부하를 줄이고 애플리케이션의 처리량을 증가시킬 수 있다.
        - Old 영역의 GC는 Mark-sweep-compact콜렉션 알고리즘을 사용한다.
    3. Parallel Compacting Collector
        - 병렬 콜렉터와 다른 점은 Old영역 GC에서 새로운 알고리즘을 사용한다. (표시-종합-컴팩션 과정)
    4. Concurrent Mark-Sweep Collector
        - 힙 메모리 영역의 크기가 클 때 적합하다.
        - Young영역에 대한 GC는 병렬콜렉터와 동일하다.
        - Old영역의 GC는 초기표시-컨커런트 표시-재표시-컨커런트 스윕 과정을 거친다
        - 2개 이상의 프로세서를 사용하는 서버에 적당하다 (ex 웹서버)
    5. Garbage First Collector
        - 모르겠다. 너무 어렵다. 나중에 다시 쓰자


강제로 GC를 시킬 수 있다. 하지만 절대 쓰지 말 것. GC를 수행하게 되면 기본 성능에 상당히 영향을 미친다
